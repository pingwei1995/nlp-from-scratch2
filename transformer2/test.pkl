from datasets import *

def test(model, enc_input, start_symbol, tgt_len, src_pad_idx):
     # 生成编码器的padding mask
    enc_mask = model.make_pad_mask(enc_input, enc_input, src_pad_idx, src_pad_idx)
    
    # 调用编码器，传入mask参数
    enc_outputs = model.encoder(enc_input, enc_mask)
    
    # 初始化解码器输入
    dec_input = torch.zeros(1, tgt_len).type_as(enc_input.data)
    next_symbol = start_symbol

    for i in range(0, tgt_len):
        dec_input[0][i] = next_symbol
        print(f"dec_input shape at step {i}: {dec_input.shape}")

        # 生成解码器需要的mask
        dec_mask = model.make_pad_mask(dec_input, dec_input, model.trg_pad_idx, model.trg_pad_idx)
        dec_mask = dec_mask * model.make_casual_mask(dec_input, dec_input)
        src_trg_mask = model.make_pad_mask(dec_input, enc_input, model.trg_pad_idx, src_pad_idx)
        
        # 调用解码器，传入所有需要的mask
        dec_outputs = model.decoder(dec_input, enc_outputs, dec_mask, src_trg_mask)
        projected = model.projection(dec_outputs)
        prob = projected[0, i].max(dim=-1, keepdim=False)[1]
        next_symbol = prob.item()

    return dec_input

# 1.准备测试数据
enc_inputs, dec_inputs, dec_outputs = make_data()
loader = Data.DataLoader(MyDataSet(enc_inputs, dec_inputs, dec_outputs), 2, True)
enc_inputs, _, _ = next(iter(loader))
print("enc_inputs:", enc_inputs)

# 2.加载模型
model = torch.load('model.pth', weights_only=False)

# 3.测试模型
predict_dec_input = test(model, 
                         enc_inputs[0].view(1, -1), 
                         start_symbol=tgt_vocab["S"],
                         tgt_len=5,
                         src_pad_idx=0 
                         )
print("predict_dec_input:", predict_dec_input)
print("enc_inputs[0].view(1, -1):", enc_inputs[0].view(1, -1))
predict = model(enc_inputs[0].view(1, -1), predict_dec_input)
print("Before max, predict:\n", predict, predict.shape)
predict = predict.data.max(1, keepdim=True)[1]


print("After max, predict:\n", predict, predict.shape)
print([src_idx2word[int(i)] for i in enc_inputs[0]], '->',
      [idx2word[n.item()] for n in predict.squeeze()])